## Index란

 DB에서 조회 및 검색을 빠르게 할 수 있는 방법, 기술, 또는 이에 쓰이는 자료구조 자체를 의미
 
 DB안의 레코드를 처음부터 full scan하지 않고 B+ Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상 시켜,
 RDBMS에서 검색 속도를 높이기 위한 기술
 
 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만든다. DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을
 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우 쿼리문 실행 속도가 느려진다. 
 
 ![image](https://user-images.githubusercontent.com/32594290/102302338-331e3d80-3f9c-11eb-8ee1-922d61f90187.png)

 자주 조회되는 칼럼에 대한 Index Table을 만들어 SELECT문이 들어왔을 때 Index Table에 있는 값들로 결과 값을 조회한다.
 따라서 Index를 잘 사용한다면 "검색"연산을 실행했을 때 성능을 올릴 수 있음.
 
 하지만, SELECT 쿼리 문장의 WHERE 조건절에
 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스 크기가 비대해져 오히려 역효과를 불러올 수 있다.
 
 #### 동작
 
 - Index Table에서 Where에 포함된 값을 검색
 
 - 해당 값의 Table_id PK를 획득
 
 - 가져온 table_id PK값으로 원본 테이블에서 값을 조회

 
## Index 자료구조

 DBMS는 인덱스를 어떻게 관리하는가?
 
### B+ Tree 인덱스 알고리즘

 일반적으로 사용되는 인덱스 알고리즘은 B+ Tree 알고리즘이다. B+ Tree 인덱스는 칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리),
 원래의 값을 이용해 인덱싱하는 알고리즘.
 
### Hash 인덱스 알고리즘

 칼럼의 값으로 해시값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원. 하지만 값을 변형해서 인덱싱하므로 특정 문자로 시작하는 값으로
 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색을 하고자 할 때는 해시 인덱스를 사용할 수 없다.
 
 주로 메모리 기반 DB에서 많이 사용
 
### 왜 Index를 생성하는데 B Tree를 사용하는가? Hash table이 더 효율적이지 않나?

 데이터에 접근하는 시간복잡도가 O(1)인 Hash Table이 더 효율적일거 같다고 생각하겠지만, SELECT 질의의 조건에는 부등호 연산(<, >)도 포함된다.
 Hash Table을 사용한다면 등호(=)연산이 아닌 부등호 연산의 경우 문제가 발생한다. 동등 연산(=)에 특화된 Hash Table은 DB의 자료구조로 적합하지 않다.
 
 
## Index 성능 및 주의 사항

 Index는 이진트리를 사용하기 때문에 기본적으로 정렬된 구조이다. 이로 인해 검색과 조회 속도를 향상시킬수 있으나 잦은 데이터의 변경
 (삽입, 수정, 삭제)이 일어난다면 Index 테이블 변경과 정렬를 하는데 드는 오버헤드 때문에 오히려 성능 저하가 일어날 수 있다.
 
 #### Insert
  
  - Index에 대한 데이터도 추가 및 정렬을 해야 하므로 그만큼 성능에 손실이 따른다.
  
 #### Delete
  
  - Index에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시로 남는다. 따라서 Row의 수는 그대로 유지된다. 이 작업이 반복된다면
  실제 데이터는 10만건인데 데이터가 100만건 있는 결과를 낳을 수 있는 것이다. 
  
 #### Update
   
  - Update의 경우 Insert와 Delete 두 경우의 문제점을 동시에 수반한다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이다.
  즉, 변경 전 데이터는 삭제되지 않고, Insert로 인한 Split도 발생한다.
 
 또한, 컬럼을 이루고 있는 데이터 형식에 따라 인덱스 성능이 악영향을 미칠 수 있다. 즉, 데이터 형식에 따라 인덱스를 만들었을 때 비효율적인
 경우가 있다는 것.
 
 예를 들어 '성별'이라는 컬럼을 이용하여 인덱스를 만들었다고 해보자. 성별은 남, 녀 두가지 경우에 대해서만 데이터가 존재할 것이다.
 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정해보면, 값의 Range가 적은 성별은 인덱스를 읽고 다시 한번
 디스크 I/O가 발생하기 때문에 그만큼 비효율적이다.
 
 따라서 데이터의 중복이 높은 컬럼(카디널리티가 낮은 컬럼)은 인덱스로 만들어도 무용지물이다. 
 

**다중 컬럼 인덱싱을 할 때는 카디널리티가 높은 컬럼에서 낮은 컬럼 순으로 인덱싱해야 효율적이다.
 
 
 #### Index 사용하면 좋은 경우
 
  - Where절에서 자주 사용되는 Column
  
  - 외래키가 사용되는 Column
  
  - Join에 자주 사용되는 Column
  
 #### Index 사용을 피해야 하는 경우
 
  - 데이터 중복도가 높은 Column (낮은 카디널리티)
  
  - DML이 자주 일어나는 Column (insert, delete, update)
 

 
 
 
 
 
 
 
 
 
 
 
 
 
