 ## Design Pattern ?
  
  - 소프트웨어 / 객체지향 프로그래밍 설계를 할 때 자주 발생하는 고질적인 문제들을 피하기 위해 사용하는 패턴
  
  - 목적: S/W 재사용성, 호환성, 유지 보수성 보장
  
  - 특징
     
     - 디자인 패턴 = 아이디어 개념 (특정 구현 X)
     
     - 프로젝트에 항상 패턴을 적용하는 것은 아니나 **추후 재사용, 호환, 유지 보수시 발생하는 문제 해결을 예방**하기 위해 패턴을 만듦
  
  > 패턴이란?   
  >
  >  각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 
     서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있다. 이러한 유사점을 패턴이라고 함.
  >
  >  패턴은 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 중요한 역할을 함.

- - - 


디자인 패턴은 **목적에 따라** 생성, 구조, 행위 패턴으로 나눌 수 있고, **범위에 따라** 클래스를 대상으로 할지, 객체를 대상으로 할지로 나눌 수 있다.

### 분류

### 1. 생성 패턴 (creational): 객체의 생성 과정에 관여하는 패턴

 - 객체 생성에 관련된 패턴
 
 - 객체 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성 제공
 
 #### 클래스
  
   **팩토리 메서드 (Factory Method) 패턴**: 객체를 생성하는 인터페이스를 정의하지만 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴.
    팩토리 메서드는 인스턴스를 만드는 것을 서브클래스에서 함. 즉, 서브클래스에 인스턴스 결정 및 책임을 위임
    
 #### 객체
 
   **추상팩토리 (Abstract Factory) 패턴**: 구체적인 클래스를 지정하지 않고 관련성이 있거나 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴
   
   **빌더 (Builder) 패턴**: 생성단계를 캡슐화. 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴
   
   **원형 (Prototype) 패턴**: 생성할 객체의 종류를 명시하는 데 원형이 되는 예시물을 이용하고 새로운 객체를 이 원형들을 복사함으로써 생성하는 패턴. 즉, 복사해서 새로운 객체를 생성, 시간 / 자원 효율성 증가
   
   **싱글톤 (Singleton) 패턴**: 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴으로, 디자인 패턴의 기초. 유일하게 존재하는 하나의 인스턴스를 보장함.

### 2. 구조 패턴 (Structural): 클래스나 객체의 합성에 관한 패턴

  - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
  
  - 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴
  
 #### 클래스/객체
 
   **적응자 (Adapter) 패턴**: 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴. 호환성이 없는 인터페이스 때문에 
   함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴.
   
 #### 객체
 
   **브리지 (Bridge) 패턴**: 추상부 / 구현부를 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴. 인터페이스와 구현의 결합도 약화
   
   **컴포지트 (Composite) 패턴**: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로 사용자가 단일/복합 객체 모두
   동일하게 다루도록 하는 패턴. 클라이언트에서 개별 객체와 복합 객체를 동일하게 사용, 트리 구조, 재귀 호출
   
   **Decorator 패턴**: 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴. 기능 확장이 필요할 때 서브 클래스 대신 쓸 수 있는 대안.
   즉, 기능을 확장하기 위해 유연성을 제공, 소스를 변경하지 않고서도 실행 가능
   
   **Facade 패턴**: 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공. 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의.
   하나의 인터페이스 제공, 인터페이스 단순화, 느슨한 결합
   
   **Proxy 패턴**: 어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴
   
### 3. 행위 패턴 (Behavioral): 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의하는 패턴

  - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  
  - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서 객체 사이의 결합도를 최소하하는 것에 중점을 둔다.
  
 #### 클래스
 
   **Interpreter 패턴**: 주어진 언어에 대해서 문법을 위한 표현 수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴.
   언어 규칙을 나타내는 클래스를 이용하여 언어 표현, 문법 변경/확장 용이
   
   ** Template 패턴**: 객체의 연산에서 알고리즘의 뼈대만 정의하고, 나머지는 서브클래스에서 이루어지게 하는 패턴. 템플릿패턴은 알고리즘의 구조는
   변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게 됨. 즉, 알고리즘 골격 구조 정의, 구체적인 단계는 서브클래스에서 정의, Hook Operation
   
 #### 객체
 
   **Chain of Responsibility 패턴**: 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴.
   요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달. 즉, 요청을 처리하는 객체들끼리 연결고리를 만들어 요청을 내부적으로 전달
   
   **Command 패턴**: 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴
   
   **Iterator 패턴**: 복합 객체의 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴
   
   **Mediator 패턴**: 한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴. 중재자는 객체들이 직접 서로 참조하지 않도록 함으로써
   객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해줌.
   객체들 간의 상호 작용을 캡슐화, 통제 집중화
   
   **Memento 패턴**: 상태 값을 미리 기록/저장해 두었다가 복구, 이전 값 저장으로 인한 오버헤드 발생
   
   **Oberserver 패턴**: 객체들 사이에 '1:N'의 의존 관계를 정의하여 어떤 객체의 상태가 변할 때 의존 관계에 있는 모든 객체들이 통지받고
   자동으로 갱신될 수 있게 만드는 패턴. 즉, 하나의 오브젝트 상태가 변할 때 의존자들에게 알리고, 필요시 자동 업데이트. 
   ex) 잡지사 : 구독자 관계 
   
   **State 패턴**: 객체 자체의 내부 상태에 따라 행위를 변경. 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락. 
   객체는 자신의 클래스가 변경되는것처럼 보이게 됨.
   
   **Strategy 패턴**: 동일 계열의 알고리즘들을 정의하고, 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것. 알고리즘을 사용하는 사용자로부터
   독립적으로 알고리즘이 변경될 수 있도록 하는 패턴. 다양한 알고리즘 각각을 하나의 클래스로 캡슐화하여 알고리즘의 대체가 가능
   
   **Visitor 패턴**: 객체 구조를 이루는 원소에 대해 수행할 연산을 표현. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을
   재정의 할 수 있음.
