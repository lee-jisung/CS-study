# TCP

## TCP란?

 - 일반적으로 TCP와 IP를 함께 사용. IP가 *데이터 배달*을 처리한다면, TCP는 *패킷을 추적 및 관리*
 
 - **신뢰성 있는 데이터** 전송을 지원하는 **연결 지향형** 프로토콜
 
 - 사전에 3-way handshake를 통해 연결, 통신 시작 ⇒ 4-way handshake를 통해 연결 해제 (가상 회선 방식)
 
 - **흐름 제어, 혼잡 제어, 오류 제어**를 통해 신뢰성 보장 ⇒ UDP 보다 전송 속도는 느리다
 
 - 데이터 전송 순서를 보장하며 데이터의 수신 여부 확인 가능
 
 - TCP 사용 예) 대부분의 웹 HTTP 통신, 이메일, 파일 전송 등..
 
 - TCP가 가산 회선 방식을 제공한다는 것은 송신측과 수신측을 연결하여 패킷을 전송하기 위한 논리적인 경로를 배정한다는 뜻
 
    - **패킷(packet)?** 인터넷 내에서 데이터를 보내기 위한 경로 배정(라우팅)을 효율적으로 하기 위해 데이터를 여러 개의 조각으로 나누어 전송하는데,
    이 때의 조각을 패킷이라고 함
    
    - **TCP는 패킷을 어떻게 추적/관리 하는가?** 데이터는 패킷 단위로 나누어 같은 목적지 (IP계층)으로 전송됨.
    각 패킷에 **번호를 부여**하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 **재조립**함 ⇒ 이러한 방식으로 TCP가 패킷을 추적 및 관리.
    
 - - - 
 
## 흐름 제어 (Flow Control)
 
 - 송신측과 수신측 사이의 **데이터 처리 속도 차이(흐름)**을 해결
  
 - '송신측 전송량' > '수신측 전송량' 의 경우 전송된 패킷은 수신측 큐에서 **Overflow**가 발생하여 손실될 가능성이 있음 ⇒ 송신 측 패킷 전송량 조절이 필요함
  
 ### 1. Stop and Wait 
   
  - 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷 전송. Give & Take 구조 ⇒ **비효율적**
    
 ### 2. Sliding Window
  
  - 수신측에서 설정한 *윈도우 크기만큼* 송신측에서 확인 응답 없이 세그먼트를 전송 ⇒ 데이터 흐름을 **동적으로 조절**하는 기법. Stop & Wait의 비효율 개선
    
  - **윈도우?** 송신, 수신 양쪽에서 만들어진 **버퍼 크기**
    
  - 송신측에서 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있음
    
  - EX) 송신측에서 [0, 1, 2, 3, 4, 5, 6] 프레임을 가지고 있는 상태에서 [0, 1]을 보내면 슬라이딩 윈도우는 [2, 3, 4, 5, 6]으로 바뀌며
    수신측으로부터 [0, 1]에 대한 ACK을 받게 되면 송신측 슬라이딩 윈도우는 [2, 3, 4, 5, 6, 7, 8]로 확장된다.
    
## 오류 제어 (Error Control)
 
 - 오류 검출과 재전송 포함
  
 - ARQ (Automatic Repeat Request) 기법을 통해 프레임이 손상 및 손실된 경우 **재전송을 통해 오류를 복구** (**흐름 제어**기법과 관련있음)
  
 ### 1. Stop and Wait ARQ
  
  - 송신측에서 1개의 프레임을 보내고, 수신측에서 수신된 프레임의 에러 유무를 판단하여 ACK or NAK을 보내는 방식
    
  - 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아 가며 부여
    
  - 수신측이 데이터를 못 받았을 경우 **NAK**을 보내고 **NAK**을 받은 송신측은 해당 데이터를 **재전송**
    
  - 네트워크 상에서 ACK이 분실된 경우 ⇒ 송신 측은 일정 시간 간격을 두고 **타임아웃**이 되면 ACK이 오지 않은 데이터를 **재전송**한다.
    
 ### 2. Go-Back-N ARQ (Sliding Window)
  
  - 전송된 프레임이 손상 및 분실된 경우 ACK 패킷의 손실로 인한 **TIME_OUT**이 발생하면 확인된(ACK을 받은) 마지막 프레임 이후 **모든 프레임을 재전송**
    
  - 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 된 모든 프레임의 복사본을 가지고 있어야 하며, ACK과 NAK을 각각 구별해야 함
    
  - ACK: 다음 프레임 전송
    
  - NAK: 손상된 프레임 자체 번호를 반환
    
 #### [재전송되는 경우 in GBN]
  
 ##### (1) NAK 프레임 받았을 경우**
    
  - 만약 수신측으로 [0 ~ 5] 까지 데이터를 보냈다고 가정 ⇒ 수신측에서 데이터를 받았음을 확인하는 ACK을 중간중간 보내게 된다. ACK 프레임을
      확인한 송신측은 계속해서 데이터를 전송함
      
  - But, 수신측에서 데이터 오류 프레임 [2]를 발견하고 NAK [2]를 송신측으로 보냈다고 가정하자
  
  - NAK[2]를 받은 송신측은 **[2]번 데이터부터 모든 데이터를 재전송**한다. (GBN ARQ 특징)
  
 ##### (2) 전송 데이터 프레임의 분실

  - GBN ARQ 특징은 확인된 데이터 이후 모든 데이터 프레임 **재전송**과 수신측의 **폐기**
  
  - 수신측에서 데이터 [1]을 받고 다음 데이터 [3]을 받은 경우 (out of order) 데이터 [2]를 받지 못했으므로, 수신측은 [3]을 폐기하고 NAK [2]를
  송신측에 보냄
  
  - NAK을 받은 송신측은 위와 같이 NAK(n) 부터 **모든 데이터를 재전송**하며 (이미 보냈을지라도) 수신측은 기존에 받았던 데이터 중 NAK(n)을 보냈던
  대상 데이터 이후 **모든 데이터를 폐기** 후 재전송 받음
  
 ##### (3) 지정된 TIME OUT 내의 ACK 프레임 분실 (Lost ACK)
 
  - 송신측은 분실된 ACK을 다루기 위한 **타이머**를 보유
  
  - 타이머의 타임아웃 동안 수신측으로부터 ACK을 받지 못했을 경우 마지막 ACK이 온 데이터부터 **재전송**
  
  - 송신측이 NAK(n) 프레임을 받았을 경우 **n번부터 재전송**

  - 수신측이 원하는 프레임이 아닐 경우 **모두 폐기**


 ### 3. SR (Selective-Reject) ARQ

  - GBN ARQ의 확인된 마지막 프레임 이후 모든 프레임을 재전송하는 단점을 보완
 
  - SR ARQ는 **손상된 or 손실된** 프레임만 재전송
 
  - 별도의 데이터 **재정렬**이 필요하며 이를 위한 별도의 버퍼가 필요함
 
  - 수신측에 버퍼를 두어 받은 데이터의 정렬 필요
 
 #### GBN ARQ vs SR ARQ
  ![image](https://user-images.githubusercontent.com/32594290/100882369-75527400-34f2-11eb-9039-4bcf0ffbc552.png)
 
 
## 혼잡 제어 (Congestion Control)

 - 송신측의 **데이터 전달**과 **네트워크 처리 속도**를 해결하기 위한 기법
 
 - 한 라우터에 데이터가 몰려 모든 데이터를 처리할 수 없는 경우 호스트들은 재전송을 하게되며 결국 혼잡만 가중시켜 Overflow/데이터손실이 발생하고
 네트워크 내에 패킷 수가 과도하게 증가하는 현상이 발생함.
 
 - 이러한 네트워크 혼잡을 피하기 위해 송신측에서 **보내는 데이터 전송 속도**를 제어하기 위한 방법
 
 ### 1. AIMD (Additive Increase Multiplicative Decrease)
 
  - 처음에 패킷 하나만 보내는 것으로 시작. 전송한 패킷이 문제없이 도착하면 **window size**를 1씩 증가시키며 전송하는 방법. 만약 패킷이 
  실패 or TIME_OUT이 발생한다면 **window size를 절반**으로 감소시킨다.
  
  - **공평한 방법이다** ⇒ 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 호스트가 처음에는 불리하지만, 시간이 흐르면 평형
  상태로 수렴하는 특징이 있기 때문
  
  - 문제점: 초기 네트워크의 높은 대역폭을 사용하지 못하며, 네트워크가 혼잡해지는 상황을 미리 감지하지 못하고 **혼잡해지고 나서 대역폭을 줄이는 방식**
  
 ### 2. Slow Start
 
  - AIMD가 네트워크 수용 가능한 범위에서는 효율적으로 동작하지만 처음에 **전송 속도를 올리는데 시간이 너무 길다**라는 단점이 존재
  
  - Slow start는 AIMD와 마찬가지로 패킷을 1개씩 보내는 것 부터 시작 ⇒ 패킷이 문제없이 도착하면 각 **패킷의 ACK 마다 Window size를 1씩 늘린다**
  즉, 한 주기가 끝나면 Window size가 2배씩 커지게 된다.
  
  - 혼잡 현상이 발생하게 되면 window size를 1로 떨어뜨리며 혼잡 현상이 발생한 window 크기의 1/2를 임계값(threshold)로 잡는다.
  
  - 처음에 네트워크 수용량을 예측할 수 있는 정보가 없지만, 한 번 혼잡현상이 발생하면 **네트워크 수용량을 어느정도 예상**할 수 있으므로
  혼잡현상이 발생했던 Window size의 절반(=임계값)까지는 이전처럼 지수 함수꼴로 Window size를 증가시키며, 그 이후부터는 **완만하게 1씩 증가**시킨다.
  
  - 결론 ⇒ 임계값(=threshold)에 도달할 때 까지 window size를 2배씩 증가 ⇒ 임계값에 다다르면 혼잡 회피 단계로 넘어간다.
  
  ![image](https://user-images.githubusercontent.com/32594290/100889593-a767d400-34fa-11eb-88f3-280f202f5450.png)
  
 #### 혼잡 회피 (Congestion Avoidance)
 
  - 윈도우 크기가 threshold에 도달한 이후부터는 데이터 손실이 발생할 확률이 높음. 이를 피하기 위해 윈도우 크기를 선형적으로 1씩 증가 시킨다.
  
  - 수신측으로부터 일정 시간 동안 ACK이 오지 못하는 경우
    
    - **TIME OUT** 발생: 네트워크 **혼잡**이 발생했다고 인식 ⇒ TImeout의 경우 네트워크 상태가 매우 안좋은 것으로 인식하여 Window size를 **1로 감소**시킨다.
    그와 동시에 threshold값을 패킷 손실이 발생한 window 크기의 절반으로 설정한다.
    
 #### 빠른 회복 (Fast Recovery)
  
  - 혼잡 상태가 되면 Window size를 **1로 줄이지 않고 절반으로 줄인 후** 다시 선형 증가 시키는 방법
  
  - 빠른 회복 정책까지 적용할 경우 혼잡 상황을 한번 겪고 난 후에는 **순수한 AIMD**방식으로 동작한다.
  
 #### 빠른 재전송 (Fast Retransmit)
  
  - 수신측에서 패킷을 받을 때 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK을 보낸다. ⇒ 이 때, 순서대로 잘 도착한
  패킷의 다음 순번을 ACK 패킷에 실어서 보낸다.
  
  - 따라서 중간에 패킷이 하나가 손실되면 송신측에서는 중복된 ACK을 받게 되는데, 이것을 감지하면 문제가 되는 순번의 패킷을 재전송할 수 있다.
  
  - 빠른 재전송은 중복된 순번의 패킷을 **3개 (3ACK)** 받으면 재전송 한다.
  
  - 이러한 현상이 일어나는 것은 **약간의 혼잡이 발생한 것**으로 간주하여 window size를 **절반**으로 줄인다.
 
