# 가상메모리

다중 프로그래밍을 실현하기 위해 많은 프로세스들을 동시에 메모리에 올려두어야 한다.

가상 메모리는 프로세스 전체가 메모리내에 올라오지 않더라도 실행이 가능하도록 하는 기법으로, 프로그램이 물리 메모리보다 커도 된다는 장점이 있다.

## 가상 메모리 개발 배경

실행되는 코드 전부를 물리 메모리에 올려야 했고, 메모리 용량보다 큰 프로그램은 실행할수 없었다. 또한, 여러 프로그램을 동시에 메모리에 올리기엔
용량의 한계와 페이지 교체 등 성능 이슈가 발생했다.

가끔 사용하는 코드가 차지하는 메모리들도 확인할 수 있다는 점에서 불필요하게 프로그램 전체가 메모리에 올라와 있어야 하는 것은 아님을 알 수 있다.

프로그램 일부만 메모리에 올려서 사용한다면?

 - 물리 메모리 크기에 제약을 받지 않음
 
 - 더 많은 프로그램을 동시에 실행할 수 있음. 이에 따라 응답 시간은 유지되고, CPU 이용률과 처리율은 더 높아짐
 
 - Swap에 필요한 입출력이 줄어들어 프로그램들이 빠르게 실행됨
 
## 가상 메모리가 하는 일

 가상 메모리는 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리한다. 이로써 작은 메모리를 갖고도 얼마든지 큰 
 가상 주소 공간을 프로그래머에게 제공한다.
 
#### 가상 주소 공간
 
 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간. 
 
 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로써 현재 직접적으로 필요하지 않은 메모리 공간은 
 실제 메모리에 올리지 않는 것으로 물리 메모리를 절약한다.
 
 Ex, 한 프로그램이 실행되며 논리 메모리로 100KB가 요구 되었을 때, 프로그램 실행까지 필요한 메모리 공간 (Stack, Code, Data) 합이 40KB라면
 실제 물리 메모리에는 40KB만 올라가 있고, 나머지 60KB는 필요시에 물리 메모리에 요구하게 된다.
 
#### 프로세스 간 페이지 공유

 가상메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 공유 라이브러리를 자신의 가상 주소 공간에
 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.
 
 가상 메모리는 **프로세스들이 메모리를 공유**하는 것을 가능하게 하며 프로세스들은 공유 메모리를 통해 통신할 수 있다.
 이 때, 프로세스들은 각자 자신의 주소 공간처럼 인식하지만 실제 메로리는 공유되고 있는 것이다.
 

## Demand Paging

 프로그램 실행 시작 시 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들을 적재하는 전략을 요구 페이징이라고 하며
 가상 메모리 시스템에서 사용한다.
 
 가상 메모리는 대게 Page로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행 과정에서 필요해질 때 page들이 적재된다.
 한 번도 접근되지 않은 page는 물리 메모리에 적재되지 않는다.
 
 프로세스 내의 개별 페이지들은 페이저(Pager)에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 들여 사용되지 않을
 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄인다.
 

### Page Fault

 물리 메모리에 올라와 있는 Page와 올라와 있지 않은 Page를 구분하기 위해 Page table에 **valid & invalid bit**를 사용한다.
 
 물리 메모리에 할당되어 있는 page는 page table의 valid bit가 1로 설정되며, Page fault는 valid bit가 0인, 즉 물리 메모리에 올라와
 있지 않은 page에 접근하게 될 때 발생한다. 이 때는 디스크에서 해당 page를 물리 메모리로 적재해야 한다.
 
 즉, CPU가 접근하려는 페이지가 메모리에 없는 경우이다. 
 
 ![image](https://user-images.githubusercontent.com/32594290/101173576-13c30e80-3686-11eb-81c8-96fcc6369ae7.png)
 
 위의 그림은 Page fault가 발생했을 때 처리하는 과정이다.
 
 1. 해당 페이지가 메모리에 있는지 valid bit를 확인한다.
 
 2. valid bit가 0이라면 CPU에 인터럽트 신호를 보내 OS 내부 해당 ISR로 점프한다.
 
 3. 해당 ISR에서 Backing Store(disk)를 탐색하여 해당 프로세스의 page를 찾는다.
 
 4. 해당 페이지를 비어있는 프레임에 할당한다.
 
 5. 페이지 테이블을 갱신한다. (프레임 번호 설정, valid bit 1로 변경)
 
 6. 다시 명령어로 돌아가 실행한다.
 

### Pure Demanding Paging

 Pure Demanding Paging은 **프로세스가 최초 실행될 때 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다.** 그러므로
 프로그램을 실행하자마자 page fault가 발생한다. 즉, 순수하게 필요한 페이지만 올리는 것을 말한다. 
 
 Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하여 속도면에서 느리다.

### Prepaging

 Prepaging은 pure demading paging과 반대되는 개념이다. 프로그램을 실행할 때 **필요할 것이라 판단되는 페이지를 미리 올리는것**이다.
 page fault가 발생할 확률이 적고 속도가 빠르다는 장점이 있으나, 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비되는 단점이 있다.
 
### Swapping vs Demanding Paging

 - Swapping과 Demanding Paging의 공통점
   
   메모리와 Backing Store 사이를 서로 오고 가는 기능 수행
   
 - 차이점
 
   Swapping: 프로세스 단위로 이동
   
   Demanding Paging: 페이지 단위로 이동
   
- - - 

## Page Replacement

Page fault 발생으로 원하는 Page를 Disk에서 가져올 때 물리 메모리에 가용한 공간이 없다면, Page Replacement가 이루어져야 한다.

#### 교체 방법

- 디스크에서 필요한 페이지 위치를 찾는다.
 
- 빈 페이지 프레임을 찾는다.

  - 페이지 교체 알고리즘을 통해 **Victim** 페이지를 고른다.
  
  - Victim 페이지를 디스크에 기록하고, 해당 페이지 테이블을 수정한다.
  
- 비워진 페이지 테이블 내 프레임에 새로운 페이지를 읽어오고, 프레임 테이블을 수정한다.

- 사용자 프로세스를 재시작 한다.

#### Modify Bit(=dirty bit)

 Victim page를 disk로 보낼 대 I/O 작업을 줄여 성능을 향상시키기 위한 Bit
 
 수정된 적이 없는 Page를 Victim Page로 결정한다면 Disk에 Write을 하는 Overhead를 줄일 수 있다. 메모리 상에서 해당 페이지만 삭제하면 되기 때문에
 Disk access time을 줄일 수 있는 것이다.
 
 따라서 수정된 적이 없는 Page를 Victim Page로 결정한다.
 
 
## Page Replacement 알고리즘

### FIFO 페이지 교체

 First in First out: 물리 메모리에 들어온 순서대로 페이지를 교체한다.
 
 장점
  
  - 이해하기 쉬우며 프로그래밍하기 쉽다.
  
 단점
 
  - 오래된 페이지가 항상 불필요하지 않은 정보를 포함할 수도 있다 (초기 변수 등..)
  
  - 처음부터 활발하게 사용되는 페이지를 교체해서 Page fault의 비율이 높아질 수 있다.
  
  - **Belady의 모순**: 페이지를 저장할 수 있는 페이지 프레임 개수를 늘려도 페이지 부재가 더 많이 발생하는 모순이 존재한다.
  
### 최적 페이지 교체 (Optimal Page Replacement)

 Belady의 모순을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 page fault 비율을 보이며 
 Belady의 모순이 발생하지 않는 알고리즘이다. 
 
 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 방법으로 주로 비교 연구 목적을 위해 사용된다.
 
 장점
 
  - 알고리즘 중 가장 낮은 Page fault 비율을 보장
  
 단점
 
  - 모든 프로세스의 메모리 참조 계획을 미리 파악할 수 없어 구현이 어렵다.
  
### LRU 페이지 교체 (Least-Recently-Used)

 최적 알고리즘의 근사 알고리즘으로 **가장 오랫동안 사용되지 않은 페이지**를 선택하여 교체한다.
 
 대체적으로 FIFO 알고리즘보다 우수하며 OPT 알고리즘보다는 성능이 낮다.
 
 Page에 대한 참조가 있을 때 마다 각 page가 사용했던 시간을 기록한다. 물리 메모리에도 이러한 정보가 필요하며 매 참조마다 Update를 해야 하기 때문에
 Overhead가 크다. 이러한 이유로 Reference bit를 사용한다.
 
 #### Reference bit
 
 한 번이라도 참조했던 page라면 Reference bit를 1로 설정한다. 
 
 Refernce bit가 0인 page 중 가장 오랫동안 사용하지 않은 page를 교체하도록 한다. 단, 모든 page의 reference bit가 1이 되는 경우가 발생할 수 있으므로
 주기적으로 모든 Page의 Ref. bit를 0으로 바꿔준다.
 
 (Modify bit와 Ref. bit를 함께 사용)
 
### LFU 페이지 교체 (Least Frequently Used)

 참조 횟수가 가장 적은 페이지를 교체하는 방법. 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 만들어 졌다.
 
 특징
 
  - 어떤 프로세스가 페이지를 집중적으로 사용했다가 다른 기능을 사용하게 되어 더이상 사용하지 않더라도 계속 메모리에 머물게 되어
  초기 가정에 어긋나는 경우가 발생
  
  - 최적(OPT)페이지 교체를 제대로 근사하지 못하기 때문에 잘 쓰이지 않는다.
  
### MFU 페이지 교체 (Most Frequently Used)

 참조 횟수가 가장 작은 페이지가 최근 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한 알고리즘
 
 최적(OPT)페이지 교체를 제대로 근사하지 못하기 때문에 잘 쓰이지 않는다.
 
- - - 

## 페이지 교체 방식

 Global 교체
  
   - 메모리 상 모든 프로세스 페이지에 대해 교체하는 방식
   
 Local 교체
 
   - 메모리 상 자기 프로세스 페이지에서만 교체하는 방식
   
 다중 프로그래밍일 경우 메인 메모리에 다양한 프로세스가 동시에 올라와 있다. 따라서 다양한 프로세스의 페이지가 메모리에 존재한다.
 
 페이지 교체시 전체를 기준(=Global)으로 페이지 교체를 하는 것이 더 효율적이다. 자신의 프로세스 페이지에서만 교체한다면 교체할 때
 각각 모두 교체를 진행해야 하기 때문에 비효율적이다.
  
 
 
 
 
 

 

 
