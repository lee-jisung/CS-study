# 메모리 관리 전략

## 메모리 관리 배경

각각의 프로세스는 독립된 메모리 공간을 갖고, OS 및 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려 있다.
  
OS만이 OS 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않음
  
### Swapping
 
메모리 관리를 위해 사용되는 기법. 

프로세스 중 오랫동안 사용하지 않은 프로세스를 '프로세스 이미지' 형태로 만들어 하드디스크 (Backing Store)로 내려보낸다. 

 - 메모리 ⇒ Backing Store 과정을 **Swap-out**
 
 - Backing Store ⇒ 메모리 과정을 **Swap-in**

여기서 프로세스 이미지는 해당 프로그램이 메모리에 적재된 후 실행되면서 데이터를 추가하거나 변경하는 등의 과정을 거치는데, 현재 데이터 상태를 
'프로세스 이미지'라고 부른다. 따라서 단순히 하드디스크에 존재하는 프로그램(exe파일)과는 전혀 다른 데이터이므로 따로 저장해야 한다.

이와 같은 Swapping 과정으로 인한 프로세스 이미지를 저장하기 위해 하드디스크 일부를 분리하여 사용하는데, 이를 **Backing Store** 또는
 **Swap Device** 라고 부른다.
    
- 실제 사용 가능한 메모리 크기보다 프로세스들의 메모리 합이 더 커질 때 발생
     
- Swap에는 큰 디스크 전송 시간이 필요하기 때문에 현재 메모리 공간이 부족할 때 swapping이 시작된다.


## 연속 메모리 관리 (Contiguous Memory Management)

프로그램 전체가 하나의 공간에 연속적으로 할당 되는 구조

메모리의 비어있는 공간을 **hole**이라고 부르며 프로세스가 이 공간에 할당되는 것.

#### 단편화 (Fragmentation)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 hole들이 늘어난다.
이것이 '단편화'이며 2가지 종류가 있다.

- 외부 단편화

  메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어
  있을 때 발생한다. ⇒ 동적 분할 기법
  
- 내부 단편화

  프로세스가 사용하는 메모리 공간에 남는 부분. EX) 메모리 분할 자유 공간이 10,000B라고 할 때, 프로세스 A가 9,998B를 사용하면 2B라는 차이가
  존재하고 이를 내부 단편화라고 한다. ⇒ 고정 분할 기법

#### Compaction (압축)

외부 단편화를 해소하기 위해 프로세스가 사용하는 공간을 한쪽으로 몰아 자유공간을 확보하는 방법. 하지만 hole을 옮기는 오버헤드가 너무 크며
어떤 hole을 옮겨야 빠르게 합칠 수 있는지에 대한 최적 알고리즘이 존재하지 않는 단점이 있다.

### 연속 메모리 할당 방식

 #### First-Fit (최초 적합) 
  
  최초 적합은 할당할 프로세스 크기보다 크거나 같은 hole을 탐색하는 순서 중 가장 먼저 찾은 hole에 프로세스를 할당하는 것
  
 #### Best-Fit (최적 적합)
 
  최적 적합은 할당할 프로세스 크기와 hole의 크기 차이가 가장 적은 hole에 프로세스를 할당하는 것. (hole 크기는 프로세스 크기보다 반드시 커야함)
  
 #### Worst-Fit (최악 적합)
 
  최적 적합과 반대로 할당할 프로세스 크기와 hole 크기 차이가 가장 큰 hole에 프로세스를 할당하는 것.
  

## 불연속 메모리 관리

프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

### Paging

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약일 없앤 방법이다. 

**외부 단편화**와 **압축**작업을 해소하기 위해 만들어 졌으며, 물리 메모리는 **Frame**이라는 고정 크기로 분리되어 있고 논리 메모리(프로세스가 점유)는
**Page**라 불리는 고정 크기의 블록으로 분리되어 있다.

페이징 기법을 사용함으로써 논리메모리는 물리메모리에 저장될 때 연속되어 저장할 필요가 없고 물리메모리의 남는 Frame에 적절히 배치됨으로써
**외부 단편화**를 해결할 수 있는 장점이 있다.

하나의 프로세스가 사용하는 공간은 여러 개의 페이지로 나뉘어 관리되며 (논리메모리에서), 개별 페이지는 
Page Table에 의해 물리 메모리 Frame과 Mapping 되어 관리된다. Page Table을 이용해서 논리 주소를 실제 메모리 주소로 바꾸어 참조한다.

#### 단점: 내부 단편화 문제의 비중이 커진다.

 예를 들어, Page 크기가 1,024B이고 프로세스 A가 3,172B를 요구한다면 3개의 Page Frame (1024 * 3 = 3072)를 할당하고도 100B가 더 필요하기 때문에
 4개의 Page Frame이 필요하다. 결론적으로 4번째 Page Frame은 924B (1024 - 100)의 공간이 낭비가 되는 문제가 발생한다.
 
#### Page Table

CPU 내부에 페이지 테이블을 만들 경우 CPU 내부 기억장치인 레지스터에 페이지 테이블이 저장된다. 장점은 주소 변환 속도가 빠르다. 하지만,
CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다.

메모리 내부에 페이지 테이블을 만들 경우 CPU와 장단점이 정 반대이다. 페이지 테이블 크기에 제한이 없지만 주소 변환 속도가 느리다.
CPU는 프로세스의 주소에 접근하기 위해 메모리에 위치한 페이지 테이블에 1번, 실제 주소로 접근하는데 1번으로 메모리에 총 **2번**접근해야 하기 때문에
속도 역시 2배로 느려진다.

이를 위해 페이지 테이블을 위한 캐시를 만들었다. 페이지 테이블을 별도의 칩(SRAM)으로 만들어 CPU와 메모리 사이에 위치시키는 것이다.
이러한 테이블을 **TLB(Translation Look-aside Buffer)**라고 부른다. 이는 CPU보다 변환속도는 느리고 메모리보다 테이블 크기는 작으나, 
CPU 보다 테이블 크기가 크고 메모리 보다 변환 속도가 빠르다.

TLB는 캐시의 역할과 동일하므로 실제 전체 페이지 테이블은 메모리에 위치해 있으며 테이블의 일부를 TLB에 가져와 사용한다. 따라서 TLB에 유효한
Page가 있을때와 없을 때의 속도 차이가 발생한다.

#### 보호

모든 주소는 페이지 테이블을 경유하기 때문에 테이블을 이용하여 보호 기능을 수행할 수 있다.

대표적으로 테이블 마다 R(read), W(write), X(execute) 비트를 두어 해당 비트가 켜져있을 때 수행이 가능하도록 만든다.

만약 RWX -> (101)일 때 쓰기작업을 시도했을 경우 CPU에 인터럽트가 발생하여 ISR(interrupt service routine)에서 강제로 해당 프로세스를 종료시킨다.

#### 공유

공유는 메모리 공간의 낭비를 위해서 사용한다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있을 때 프로세스 메모리는 Code + Data + Stack 영역으로
할당되는데, 프로그램이 같다면 Code 영역은 같을 것이다.

그러므로 하나의 Code 영역을 복수 개의 프로세스가 공유한다면 메모리 낭비를 줄일 수 있다. 단, Code 영역이 공유되려면 code가 변하지 않는 프로그램
이어야 한다. 이러한 프로그램을 **non-self-modifying code = reentrant code (재진입가능 코드) = pure code**라고 한다.

#### 페이지 테이블을 통한 주소 변환 방법

 - 논리 주소 (Logical Address)
 
   CPU가 내는 주소는 2진수로 표현되고, 이를 m 비트가 있다고 가정하자. 여기서 하위 n비트는 offset 또는 변위(displacement)라고 한다.
   그리고 상위 m-n 비트는 페이지 번호에 해당한다 (n = d, m-n = p)
   
 논리 주소를 물리 주소로 변환하기 위해서 페이지 번호(p)는 페이지 테이블의 인덱스 값이고, p에 해당하는 테이블 내용은 메모리 프레임 번호이다.
 변위 (d)는 변하지 않는 값이다.
 
  - Page size = 16bytes
  
  - Page Table: 5, 3, 2, 8, 1, 4
  
  - 논리 주소 50은 물리 주소 몇번인가?
  
 ![image](https://user-images.githubusercontent.com/32594290/101167048-a5c61980-367c-11eb-9b34-a3209b04a658.png)
 
 위의 그림은 프로세스 P가 메모리에 할당된 모습이다. CPU가 50번지에 접근하려고 할 때 page table의 정보를 읽기 위해 논리 주소를 p와 d 값으로 나눈다.
 
 d는 페이지 크기에 따라 달라지며 현재 페이지 크기는 16byte이므로 **2^4 => d = 4**이다.
 
 p는 d를 제외한 나머지 크기이다.
 
 실제 p, d를 계산해보면 현재 논리 주소는 50이고 이진수로 나타내면 **110010**이다. 먼저 d는 '4'이므로 이 이진수 뒤에서 4칸이 d이다.
 d를 제외한 나머지 2칸이 p가 된다.
 
 ```
 50 = 110010
 p = 11
 d = 0010
 ```
 
 p (11)은 10진수로 3이다. 즉, 페이지 테이블의 번호 3번을 가리킨다. 3번에 해당하는 프레임 번호는 8번이므로 물리 주소를 구성하는 f값은 8이 된다.
 
 ```
 f = 1000
 d = 0010
 물리주소 = 10000010
 ```

 최종적으로 물리 주소는 f와 d로 구성되어 있으므로 이진수로 **10000010**이 되고, 10진수로 **130**번지가 된다. 즉 변위는 2이므로
 8번째 프레임의 시작 주소는 128번지 (16*8)가 된다.
 
- - -

### Segmentation 

Paging처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 **서로 다른 크기의 논리적 단위 Segment**로 분할하여 
사용자가 두 개의 주소를 지정한다 (segment 번호 + 변위)

Segment Table에는 각 Segment의 Base(=segment 시작 물리 주소)과 Limit(=segment 길이)를 저장한다.

![image](https://user-images.githubusercontent.com/32594290/101166800-36e8c080-367c-11eb-8fc8-58b9515b03ec.png)

위의 그림은 Segment Table과 Process가 할당된 메모리 모습이다. 'd'는 논리주소와 물리주소가 동일하며 물리주소의 'a'는 **base[s] + d**로 계산한다.

 - 논리 주소 (2, 100) ⇒ 물리주소 4400
 
 - 논리 주소 (1, 500) ⇒ 인터럽트로 인해 프로세스 강제 종료 (범위 벗어남)

**내부 단편화**가 없으며 메모리 사용 효율을 개선하였고, 동적 분할을 통한 오버헤드 감소를 이루었다.

#### 단점

 서로 다른 크기의 Segment들이 메모리에 적재되고 제거되는 일이 반복되면서 **외부 단편화** 문제가 발생할 수 있다.
 
#### 보호 & 공유

페이징보다 세그멘테이션에서의 보호 & 공유는 더 효율적이다.

보호에서는 세그멘테이션 역시 r, w, x 비트를 테이블에 추가하는데, 세그멘테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 
매우 간단하고 안전하다. 

페이징은 Code + Data + Stack 영역이 있을 때 이를 일정한 크기로 나누므로 두 가지 영역이 섞일 수 있다. 그러면 비트를 설정하기 매우 까다롭다.

공유도 마찬가지이다. 페이징에서는 Code 영역을 나눈다 해도 다른 영역이 포함될 확률이 매우 높다. 하지만 세그멘테이션은 정확히 Code 영역만
나누기 때문에 더 효율적으로 공유를 수행할 수 있다.

- - -

## Segmentation & Paging

Segmentation은 Paging과 유사하고 보호와 공유에서는 더 나은 성능을 보여주나, 현재 대부분은 **Paging**기법을 사용한다.
그 이유는 Segmentation에 치명적인 단점이 있기 때문이다.

메모리 할당을 처음 시작할 때, **다중 프로그래밍에서의 문제**는 크기가 서로 다른 프로세스로 인해 여러 크기의 'hole'이 발생한다.
이 때문에 어떤 'hole'에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다.

Segmentation에서도 논리적인 단위로 나누기 때문에 **Segment 크기가 다양**하다. 이로 인해 다양한 크기의 hole이 발생하여 동일한 문제가 발생한다.

즉, Segmentation은 보호와 공유에서 효율적이고 Paging은 외부 단편화 문제를 해결할 수 있다. 이 두가지의 장점을 모두 가져가기 위한 방법인
**Paged Segmentation (세그먼트를 페이징 기법으로 나눈 것)**이 나왔으나, 단점 역시 존재한다.

Segment와 Page가 동시에 존재하기 때문에 주소 변환도 2번해야 한다. CPU에서 Segment table을 통해 주소 변환을 하고, 그 다음 Page table을 통해
주소 변환을 해야 한다.
