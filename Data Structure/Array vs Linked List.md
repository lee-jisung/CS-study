### Array
  
 ![image](https://user-images.githubusercontent.com/32594290/102681867-4f261700-4208-11eb-8ead-bec4432ea5fe.png)

 가장 기본적인 자료구조로 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스(index)로 해당 원소(element)에 접근할 수 있다.
 
 따라서 찾고자 하는 원소의 인덱스 값을 알고 있으면 Big O(1)에 해당 원소로 접근할 수 있다. 즉 **random access**가 가능하다는 장점이 있다.
 
 하지만 삭제, 삽입 시 해당 원소에 접근하여 작업을 완료한 후(O(1)), 또 한 가지 작업을 추가적으로 해줘야 해서 시간이 더 소요된다.
 
 만약 배열의 원소 중 임의의 원소를 삭제했을때, 배열의 연속적인 특징이 깨진다. 즉, 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스
 값을 갖는 원소들을 **shift**를 해줘야 하는 비용(cost)이 발생하고, 이 경우 시간 복잡도는 O(n)이 된다. 그렇기 때문에 Array 자료구조에서
 삭제 기능에 대한 time complexity의 worst case는 O(n)이다.
 
 삽입도 동일하다. 만약 첫 번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1씩 shift 해야 하므로 이 경우에도 O(n)의
 시간이 소요된다.
 
### Linked List

![image](https://user-images.githubusercontent.com/32594290/102682129-6cf47b80-420a-11eb-941a-9276bcee2039.png)

 Array의 삽입, 삭제를 해결하기 위한 자료구조가 linked list이다. 각각의 원소들은 자기 자신 다음에 어떤 원소가 오는지를 기억하고 있다.
 
 따라서 이 부분만 다른 값으로 바꿔주면 삽입, 삭제를 O(1)만에 해결할 수 있다.
 
 하지만, Linked list 역시 한 가지 문제가 있다. 원하는 위치에 삽입하기 위해서는 해당 위치를 Search하는 데 첫 번째 원소부터 전부 확인해봐야 한다.
 
 Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이 과정으로 인해서 임의의 원소를 삭제, 삽입하기 위해 해당 원소를 
 찾는 과정에서 O(n)의 시간이 추가적으로 발생한다.
 
 결국 Linked list 자료구조는 Search, 삽입, 삭제에 대해서 O(n)의 time complexity를 갖는다. 그러나 아주 쓸모없는 자료구조는 아니다.
 
 Tree 자료구조의 근간이 되며, Tree에서 사용되었을 때 유용성이 드러난다.
 
### 메모리 할당

 - Array
 
   메모리에는 Array가 선언되자마자 Compile time에 할당된다.
   
   정적 메모리 할당이라고 한다.
   
 - Linked list
 
   메모리는 새로운 Node가 추가될 때 runtime에 할당된다.
   
   동적 메모리 할당이라고 한다.
 
### 결론

 - 삽입과 삭제가 빈번하게 일어난다면 Linked list를 사용하는 것이 좋다.
 
 - 데이터에 접근하는 것이 빈번하게 일어난다면 Array를 사용하는 것이 좋다.
