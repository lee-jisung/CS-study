## Tree

![image](https://user-images.githubusercontent.com/32594290/102683233-b943b980-4212-11eb-9a40-d26bec198815.png)

## 트리 개념

 트리 자료구조는 왜 등장하였는가?
 
 일반 배열에서 삽입, 삭제를 하는데는 최악의 경우 O(n)의 시간이 소요된다. 하지만 트리는 편향 트리가 아닌 이상 O(logN) 정도의 시간으로 줄여진다.
 
 또한, 계층 구조를 이루는 데이터를 표현하기가 좋다. 예를들어 회사, 정부의 조직 구조 등 계층적인 데이터 형태를 저장하면 자연스럽게 표현이 된다.
 
## 트리 구성 요소

 - Node(노드): 트리를 구성하는 각각의 요소
 
 - Edge(간선): 트리를 구성하는 노드와 노드를 연결하는 선
 
 - Root Node(루트 노드): 트리 구조에서 최상위에 있는 노드
 
 - Terminal Node(=Leaf Node, 단말 노드): 하위에 다른 노드가 연결되어 있지 않은 노드
 
 - Internal Node(내부 노드, 비단말 노드): 단말 노드를 제외한 모든 노드로 루트 노드를 포함
 
 - - -

## Binary Tree (이진 트리)

 ![image](https://user-images.githubusercontent.com/32594290/102683207-9913fa80-4212-11eb-99c0-1b77a13af2c7.png)

 루트 노드를 중심으로 두 개의 서브 트리로 나뉜다. (노드가 없을 수도 있다.) 나뉘어진 두 서브 트리도 모두 이진 트리어야 한다.
 
 각 층별로 숫자를 매겨 이를 트리의 레벨이라고 한다. 레벨은 1부터 시작하고, 루트 노드의 레벨은 1이다. 트리의 최고 레벨을 가리켜 
 트리의 높이라고 한다.
 
### 이진 트리 종류
 
 #### Full Binary Tree (포화 이진 트리)
 
  - 모든 레벨이 꽉 찬 이진 트리
  
  - 레벨 별로 노드의 개수가 1, 2, 4, 8, 16...으로 늘어난다. 따라서 일반적은 이진 트리에서 각 레벨 별 최대 노드의 개수는 2^(k-1)이 된다.
  
  - 레벨 별 노드는 공비가 2인 등비 수열이라고 볼 수 있으므로 등비수열의 합으로 생각하면 높이가 h인 이진트리가 가질 수 있는 최대 노드 수는
  2^h - 1이다.
  
 #### Complete Binary Tree (완전 이진 트리)
 
  - 왼쪽에서 오른쪽으로 순서대로 채워진 이진트리
  
  - 노드를 삽입할 때 왼쪽부터 차례대로 삽입하는 트리. 왼쪽이 비어있고 오른쪽이 들어가 있으면 완전 이진 트리가 아니다.
  
 #### Skewed Binary Tree (편향 이진 트리)
 
  - 모든 노드가 부모의 왼쪽 자식 혹은 오른쪽 자식으로 한쪽으로 편향되어 있는 트리

- - -
 
## BST (Binary Search Tree)

 효율적인 탐색을 위한 저장방법으로 이진 트리의 일종. 
 
 ### 이진 탐색 트리에 데이터를 저장하는 규칙
 
  - 이진 탐색 트리의 노드에 저장된 키는 유일하다.
  
  - 부모의 키가 왼쪽 자식 노드의 키보다 크다
  
  - 부모의 키가 오른쪽 자식 노드의 키보다 작다
  
  - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
  
 이진 탐색 트리 연산은 O(logN)의 시간 복잡도를 갖는다. 트리의 높이를 하나씩 더해 갈수록 추가할 수 있는 노드의 수가
 2배씩 증가하기 때문에 정확히 말하면 O(h)이다. 하지만 이러한 이진 탐색 트리는 *Skewed Tree*가 될 수 있다. 저장 순서에 따라 한쪽으로만
 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치게 되며 탐색의 Worst case가 O(n)이 될 수 있다.
 
 배열보다 많은 메모리를 사용하며 데이터를 저장했으나 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해
 **Rebalancing** 기법이 등장했다. 균형을 위한 트리 구조의 재조정을 의미하며 이 기법을 구현한 트리는 여러 종류가 있는데 그 중 하나가 
 *Red-Black Tree*이다.
 
- - -

## Red-Black Tree
 
 ![image](https://user-images.githubusercontent.com/32594290/102684427-c87b3500-421b-11eb-83db-21a66eab6817.png)

자가 균형 이진 트리(self-balancing binary search tree)로 대표적으로 연관 배열 등을 구현하는 데 쓰이는 자료구조

### 특성

 각각의 노드가 레드나 블랙인 색상 속성을 갖고 있는 이진 탐색 트리로 일반적인 이진 탐색 트리의 조건 이외의 추가적인 조건을 만족해야 한다.
 
  - 노드는 레드 혹은 블랙 중 하나이다.
  
  - 루트 노드는 블랙이다.
  
  - 모든 리프 노드들(NIL)은 블랙이다.
  
  - 레드 노드의 자식 노드 양쪽은 언제나 모두 블랙이다 (즉, 레드 노드는 연달아 나타날 수 없으며 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다)
  
  - 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.
  
위의 조건들을 모두 만족하면 레드-블랙 트리는 가장 중요한 특성을 나타낸다. **루트 노드로부터 가장 먼 경로까지의 거리가 가장 가까운 경로까지의
거리의 두 배보다 항상 작다.** 다시 말해 레드-블랙 트리는 개략적(roughly)으로 균형이 잡혀있다.(balanced)

따라서 삽입, 삭제, 검색 시 최악의 경우(worst case)에도 시간복잡도가 트리의 높이에 따라 결정되기 때문에 보통의 이진 탐색 트리에 비해 
효율적이라고 할 수 있다.

```
네 번째 특성에 따라 어떤 경로에도 레드 노드가 연이어 나타날 수 없다. 최단 경로는 모두 블랙 노드로만 구성되어 있다고
가정할 때, 최장 경로는 블랙 노드와 레드 노드가 번갈아 가며 나오게 될 것이다. 

다섯 번째 특성에 따라 모든 경로에서 블랙 노드의 수가 같다고 했기 때문에 
존재하는 모든 경로에 대해 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없다.
```

NIL은 데이터를 갖고 있지 않은, 트리의 끝을 나타내는 데에 쓰이는 노드이다. 트리 구조를 그림으로 표현할 때 종종 이 "null leaf"를 
생략하고 그리는 경우가 많은데, 그러면 그림상으로는 레드-블랙 트리 특성을 만족하지 못하는 것처럼 보일 수 있으나 실제로는 그렇지 않다.

NIL을 통해서 모든 노드들은 설령 하나 혹은 두개의 자식이 "null leaf"라도 두 개의 자식을 가지게 된다.

간혹 레드-블랙 트리를 노드가 아닌 붉은색 또는 검은색 선분(edge)으로 설명하기도 하는데 실제로는 같은 설명이다. 어떤 노드의 색은 노드와
그 부모를 연결하는 선분의 색이 대응되기 때문인데, 차이점이 있다면 레드-블랙 트리의 두 번째 속성에서 언급된 root noed가 선분으로 설명할 경우
존재하지 않는다는 점이다.

### 용도와 장점

 레드-블랙 트리는 자료의 삽입, 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다. 이는 실시간 처리와 같은 실행 시간이 중요한 경우에
 유용하게 쓰일 뿐만 아니라, 일정한 실행 시간을 보장하는 또 다른 자료구조를 만드는 데에도 쓸모가 있다. 예를 들면, 각종 기하학 계산에 쓰이는
 많은 자료구조들이 레드-블랙 트리를 기반으로 만들어져 있다.
 
 AVL 트리는 레드-블랙 트리보다 더 염격하게 균형이 잡혀있기 때문에 삽입, 삭제를 할 때 최악의 경우 더 많은 회전(rotation)이 필요하다.
 
 레드-블랙 트리는 **함수형 프로그래밍**에서 특히 유용한데, 함수형 프로그래밍에서 쓰이는 **연관 배열**이나 집합(set)등을 내부적으로 
 레드-블랙 트리로 구현해 놓은 경우가 많다. 이런 구현에는 삽입, 삭제시 O(logN)만큼의 시간이 필요하다.

 _BST의 삽입 삭제 연산 과정에서 발생하는 문제점을 어떻게 해결한 것인가?_
 
 #### 삽입
 
  우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색을 **RED**로 지정한다. red로 지정하는 이유는 Black-Height의 변경을
  최소화하기 위함이다. 삽입 결과 BST의 특성에 위배(violation)시 노드의 색을 조정하고, Black-Height가 위배되었다면 rotation을 통해
  height을 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node 들의 black-height가 같아지게 되고 최소 경로와
  최대 경로의 차이가 2배 미만으로 유지된다.
  
  > Black-Height: 노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수
  
 #### 삭제
 
  삭제도 삽입과 마찬가지로 BST의 특성을 유지하며 해당 노드를 삭제한다. 삭제될 노드의 child 개수에 따라 rotation 방법이 달라진다.
  만약 지워진 노드의 색이 Black이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고 노드의 색을 조정한다.
  지워진 노드의 색이 Red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.
  
Java Collection에서 ArrayList도 내부적으로 RBT로 이루어져 있고, HashMap에서의 Seperate Chaining에서도 사용된다.
 
